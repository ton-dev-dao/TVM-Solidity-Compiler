/* automatically generated by rust-bindgen 0.60.1 */

pub const __bool_true_false_are_defined: u32 = 1;
pub const false_: u32 = 0;
pub const true_: u32 = 1;
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___OFFSETOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __XSI_VISIBLE: u32 = 700;
pub const __BSD_VISIBLE: u32 = 1;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __EXT1_VISIBLE: u32 = 1;
pub const __CHAR_BIT: u32 = 8;
pub const __SCHAR_MAX: u32 = 127;
pub const __SCHAR_MIN: i32 = -128;
pub const __UCHAR_MAX: u32 = 255;
pub const __USHRT_MAX: u32 = 65535;
pub const __SHRT_MAX: u32 = 32767;
pub const __SHRT_MIN: i32 = -32768;
pub const __UINT_MAX: u32 = 4294967295;
pub const __INT_MAX: u32 = 2147483647;
pub const __INT_MIN: i32 = -2147483648;
pub const __ULONG_MAX: i32 = -1;
pub const __LONG_MAX: u64 = 9223372036854775807;
pub const __LONG_MIN: i64 = -9223372036854775808;
pub const __ULLONG_MAX: i32 = -1;
pub const __LLONG_MAX: u64 = 9223372036854775807;
pub const __LLONG_MIN: i64 = -9223372036854775808;
pub const __SSIZE_MAX: u64 = 9223372036854775807;
pub const __SIZE_T_MAX: i32 = -1;
pub const __OFF_MAX: u64 = 9223372036854775807;
pub const __OFF_MIN: i64 = -9223372036854775808;
pub const __UQUAD_MAX: i32 = -1;
pub const __QUAD_MAX: u64 = 9223372036854775807;
pub const __QUAD_MIN: i64 = -9223372036854775808;
pub const __LONG_BIT: u32 = 64;
pub const __WORD_BIT: u32 = 32;
pub const __MINSIGSTKSZ: u32 = 2048;
pub const __WCHAR_MIN: i32 = -2147483648;
pub const __WCHAR_MAX: u32 = 2147483647;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __clock_t = __int32_t;
pub type __critical_t = __int64_t;
pub type __double_t = f64;
pub type __float_t = f32;
pub type __intfptr_t = __int64_t;
pub type __intptr_t = __int64_t;
pub type __intmax_t = __int64_t;
pub type __int_fast8_t = __int32_t;
pub type __int_fast16_t = __int32_t;
pub type __int_fast32_t = __int32_t;
pub type __int_fast64_t = __int64_t;
pub type __int_least8_t = __int8_t;
pub type __int_least16_t = __int16_t;
pub type __int_least32_t = __int32_t;
pub type __int_least64_t = __int64_t;
pub type __ptrdiff_t = __int64_t;
pub type __register_t = __int64_t;
pub type __segsz_t = __int64_t;
pub type __size_t = __uint64_t;
pub type __ssize_t = __int64_t;
pub type __time_t = __int64_t;
pub type __uintfptr_t = __uint64_t;
pub type __uintptr_t = __uint64_t;
pub type __uintmax_t = __uint64_t;
pub type __uint_fast8_t = __uint32_t;
pub type __uint_fast16_t = __uint32_t;
pub type __uint_fast32_t = __uint32_t;
pub type __uint_fast64_t = __uint64_t;
pub type __uint_least8_t = __uint8_t;
pub type __uint_least16_t = __uint16_t;
pub type __uint_least32_t = __uint32_t;
pub type __uint_least64_t = __uint64_t;
pub type __u_register_t = __uint64_t;
pub type __vm_offset_t = __uint64_t;
pub type __vm_paddr_t = __uint64_t;
pub type __vm_size_t = __uint64_t;
pub type ___wchar_t = ::std::os::raw::c_int;
pub type __blksize_t = __int32_t;
pub type __blkcnt_t = __int64_t;
pub type __clockid_t = __int32_t;
pub type __fflags_t = __uint32_t;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint64_t;
pub type __gid_t = __uint32_t;
pub type __id_t = __int64_t;
pub type __ino_t = __uint64_t;
pub type __key_t = ::std::os::raw::c_long;
pub type __lwpid_t = __int32_t;
pub type __mode_t = __uint16_t;
pub type __accmode_t = ::std::os::raw::c_int;
pub type __nl_item = ::std::os::raw::c_int;
pub type __nlink_t = __uint64_t;
pub type __off_t = __int64_t;
pub type __off64_t = __int64_t;
pub type __pid_t = __int32_t;
pub type __rlim_t = __int64_t;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __suseconds_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __timer {
    _unused: [u8; 0],
}
pub type __timer_t = *mut __timer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __mq {
    _unused: [u8; 0],
}
pub type __mqd_t = *mut __mq;
pub type __uid_t = __uint32_t;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __cpuwhich_t = ::std::os::raw::c_int;
pub type __cpulevel_t = ::std::os::raw::c_int;
pub type __cpusetid_t = ::std::os::raw::c_int;
pub type __daddr_t = __int64_t;
pub type __ct_rune_t = ::std::os::raw::c_int;
pub type __rune_t = __ct_rune_t;
pub type __wint_t = __ct_rune_t;
pub type __char16_t = __uint_least16_t;
pub type __char32_t = __uint_least32_t;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __max_align_t {
    pub __max_align1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __max_align2: u128,
}
#[test]
fn bindgen_test_layout___max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<__max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(__max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(__max_align_t))
    );
    fn test_field___max_align1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__max_align_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__max_align1) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__max_align_t),
                "::",
                stringify!(__max_align1)
            )
        );
    }
    test_field___max_align1();
    fn test_field___max_align2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__max_align_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__max_align2) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__max_align_t),
                "::",
                stringify!(__max_align2)
            )
        );
    }
    test_field___max_align2();
}
pub type __dev_t = __uint64_t;
pub type __fixpt_t = __uint32_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: __int64_t,
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    fn test_field___mbstate8() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__mbstate_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__mbstate8) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t),
                "::",
                stringify!(__mbstate8)
            )
        );
    }
    test_field___mbstate8();
    fn test_field__mbstateL() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__mbstate_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._mbstateL) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t),
                "::",
                stringify!(_mbstateL)
            )
        );
    }
    test_field__mbstateL();
}
pub type __rman_res_t = __uintmax_t;
pub type __va_list = __builtin_va_list;
pub type __gnuc_va_list = __va_list;
pub type rune_t = __rune_t;
pub type size_t = __size_t;
pub type wchar_t = ___wchar_t;
pub type max_align_t = __max_align_t;
pub type rsize_t = size_t;
#[doc = " Callback used to retrieve additional source files or data."]
#[doc = ""]
#[doc = " @param _context The readContext passed to solidity_compile. Can be NULL."]
#[doc = " @param _kind The kind of callback (a string)."]
#[doc = " @param _data The data for the callback (a string)."]
#[doc = " @param o_contents A pointer to the contents of the file, if found. Allocated via solidity_alloc()."]
#[doc = " @param o_error A pointer to an error message, if there is one."]
#[doc = ""]
#[doc = " The file (as well as error) contents that is to be allocated by the callback"]
#[doc = " implementor must use the solidity_alloc() API to allocate its underlying"]
#[doc = " storage. Ownership is then transferred to the compiler which will take care"]
#[doc = " of the deallocation."]
#[doc = ""]
#[doc = " If the callback is not supported, *o_contents and *o_error must be set to NULL."]
pub type CStyleReadFileCallback = ::std::option::Option<
    unsafe extern "C" fn(
        _context: *mut ::std::os::raw::c_void,
        _kind: *const ::std::os::raw::c_char,
        _data: *const ::std::os::raw::c_char,
        o_contents: *mut *mut ::std::os::raw::c_char,
        o_error: *mut *mut ::std::os::raw::c_char,
    ),
>;
extern "C" {
    #[doc = " Returns the complete license document."]
    #[doc = ""]
    #[doc = " The pointer returned must NOT be freed by the caller."]
    pub fn solidity_license() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the compiler version."]
    #[doc = ""]
    #[doc = " The pointer returned must NOT be freed by the caller."]
    pub fn solidity_version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Allocates a chunk of memory of @p _size bytes."]
    #[doc = ""]
    #[doc = " Use this function inside callbacks to allocate data that is to be passed to"]
    #[doc = " the compiler. You may use solidity_free() or solidity_reset() to free this"]
    #[doc = " memory again but it is not required as the compiler takes ownership for any"]
    #[doc = " data passed to it via callbacks."]
    #[doc = ""]
    #[doc = " This function will return NULL if the requested memory region could not be allocated."]
    pub fn solidity_alloc(_size: size_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Explicitly frees the memory (@p _data) that was being allocated with solidity_alloc()"]
    #[doc = " or returned by a call to solidity_compile()."]
    #[doc = ""]
    #[doc = " Important, this call will abort() in case of any invalid argument being passed to this call."]
    pub fn solidity_free(_data: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Takes a \"Standard Input JSON\" and an optional callback (can be set to null). Returns"]
    #[doc = " a \"Standard Output JSON\". Both are to be UTF-8 encoded."]
    #[doc = ""]
    #[doc = " @param _input The input JSON to process."]
    #[doc = " @param _readCallback The optional callback pointer. Can be NULL, but if not NULL,"]
    #[doc = "                      it can be called by the compiler to request additional input."]
    #[doc = "                      Please see the documentation of the type for details."]
    #[doc = " @param _readContext An optional context pointer passed to _readCallback. Can be NULL."]
    #[doc = ""]
    #[doc = " @returns A pointer to the result. The pointer returned must be freed by the caller using solidity_free() or solidity_reset()."]
    pub fn solidity_compile(
        _input: *const ::std::os::raw::c_char,
        _readCallback: CStyleReadFileCallback,
        _readContext: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Frees up any allocated memory."]
    #[doc = ""]
    #[doc = " NOTE: the pointer returned by solidity_compile as well as any other pointer retrieved via solidity_alloc()"]
    #[doc = " is invalid after calling this!"]
    pub fn solidity_reset();
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    fn test_field_gp_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__va_list_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(gp_offset)
            )
        );
    }
    test_field_gp_offset();
    fn test_field_fp_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__va_list_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(fp_offset)
            )
        );
    }
    test_field_fp_offset();
    fn test_field_overflow_arg_area() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__va_list_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(overflow_arg_area)
            )
        );
    }
    test_field_overflow_arg_area();
    fn test_field_reg_save_area() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__va_list_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(reg_save_area)
            )
        );
    }
    test_field_reg_save_area();
}
extern "C" {
    pub fn file_reader_new() -> *mut ::std::os::raw::c_void;
    pub fn file_reader_set_base_path(
        fr: *mut ::std::os::raw::c_void,
        path: *const ::std::os::raw::c_char,
    );
    pub fn file_reader_add_include_path(
        fr: *mut ::std::os::raw::c_void,
        path: *const ::std::os::raw::c_char,
    );
    pub fn file_reader_allow_directory(
        fr: *mut ::std::os::raw::c_void,
        path: *const ::std::os::raw::c_char,
    );
    pub fn file_reader_add_or_update_file(
        fr: *mut ::std::os::raw::c_void,
        path: *const ::std::os::raw::c_char,
        content: *const ::std::os::raw::c_char,
    );
    pub fn file_reader_source_unit_name(
        fr: *mut ::std::os::raw::c_void,
        path: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn file_reader_read(
        fr: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        success: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
